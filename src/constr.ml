(* ---------------------------------------------------------------------- *)
(* Constraints                                                            *)
(* ---------------------------------------------------------------------- *)

(* Type of constraints generated by the type-checker.
   A constraint has the form

    - equality constraints (S = S') between size expressions
    - inequality constraints (S <= S') between size expressions
    - plus usual connectives like /\, \/, -> and existential and universal quantification
*)

open IndexSyntax
open Support.FileInfo

(* Constraints  *)
type constr =
  | CTrue
  | CFalse
  | CEq of iterm * iterm
  | CLeq of iterm * iterm
  | CAnd of constr * constr
  | COr of constr * constr
  | CImpl of constr * constr
  | CForall of var_info  * info * sort * constr
  | CExists of var_info * info * sort * constr


let empty_constr = CTrue

let rec constr_free_i_vars (cs: constr) : var_info list =
match cs with
| CTrue | CFalse -> []
| CEq (it1, it2) 
| CLeq (it1, it2) -> dedup  (iterm_free_i_vars it1 @ iterm_free_i_vars it2)
| CAnd (cs1, cs2) 
| COr (cs1, cs2) 
| CImpl (cs1, cs2) -> dedup (constr_free_i_vars cs1 @ constr_free_i_vars cs2)
| CForall(x,i, s, cs') 
| CExists(x,i, s, cs') -> List.filter (fun y -> x.v_name <> y.v_name ) (constr_free_i_vars cs')
 
  

(* Substitution cs[it/x] for index vars *)
let rec constr_subst x it cs =
 let csub = constr_subst x it in
 match cs with
  | CTrue | CFalse -> cs
  | CEq (it1, it2) -> CEq (iterm_subst x it it1, iterm_subst x it it2)
  | CLeq (it1, it2) -> CLeq (iterm_subst x it it1, iterm_subst x it it2)
  | CAnd (cs1, cs2) -> CAnd (csub cs1, csub cs2)
  | COr (cs1, cs2) -> COr (csub cs1, csub cs2)
  | CImpl (cs1, cs2) -> CImpl (csub cs1, csub cs2)
  | CForall(y, i, s, cs') -> if x = y then csub cs' else CForall(y, i, s, csub cs')
  | CExists(y, i, s, cs') -> if x = y then csub cs' else CExists(y, i, s, csub cs')

let rec constr_map f cs =
 let cmap = constr_map f in
 match cs with
  | CTrue | CFalse -> cs
  | CEq (IConst 0.0, IConst 0.0) -> CTrue
  | CEq (it1, it2) -> if it1 = it2 then CTrue else CEq (f it1,f it2)
  | CLeq (IConst 0.0, IConst 0.0) -> CTrue
  | CLeq (IZero, IZero) -> CTrue
  | CLeq (it1, it2) -> if it1 = it2 then CTrue else CLeq (f it1, f it2)
  | CAnd (cs1, cs2) -> 
    let r1 = cmap cs1 in
    let r2 = cmap cs2 in
    if r1 = CTrue then r2 else if r2 = CTrue then r1 else CAnd (r1,r2)
  | COr (cs1, cs2) -> COr (cmap cs1, cmap cs2)
  | CImpl (cs1, cs2) -> CImpl (cmap cs1, cmap cs2)
  | CForall(x, i, s, cs') -> CForall(x, i, s, cmap cs')
  | CExists(x, i, s, cs') -> CExists(x, i, s, cmap cs')

let constr_simpl cs = 
constr_map iterm_simpl cs

let merge_cs c1 c2 =
  match c1,c2 with
  | CTrue, _ -> c2
  | _, CTrue -> c1
  | _, _ -> CAnd (c1,c2)



let rec  quantify_all_exist psi_ctx c : constr =
match psi_ctx with
| [] -> c
| (id,s) :: tl ->  CExists (id, EXISTQ, s, (quantify_all_exist tl c))


let option_combine (sl : iterm option) (sr : iterm option) (f: iterm * iterm -> 'a ) : 'a option =
match sl, sr with
| Some x, Some y -> Some (f (x, y))
| _ -> None


(* this helper function should disappear or be modified once the quantifications have sorts*)
let is_in_ctx v in_ctx : bool =
List.mem v (List.map fst in_ctx)



